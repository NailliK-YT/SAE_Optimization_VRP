<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisation Des Tourn√©es - SAE2026</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }

        #canvas-container {
            position: relative;
            width: 100%;
            height: 600px;
            background: #f8fafc;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            cursor: grab;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .control-btn {
            background: white;
            border: 1px solid #e2e8f0;
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            user-select: none;
        }

        .control-btn:hover {
            background: #f1f5f9;
        }

        .help-text {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            color: #64748b;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>

<body class="p-8">
    <div class="max-w-6xl mx-auto">
        <header class="mb-8">
            <h1 class="text-3xl font-bold text-gray-900">Optimisation des Tourn√©es (CVRP)</h1>
            <p class="text-gray-600 mt-2">Visualisation interactive : Zoomez et d√©placez la carte</p>
            <div class="mt-4 flex gap-4 text-sm">
                <div class="px-3 py-1 bg-green-100 text-green-800 rounded-full">Distance Totale: 31.3</div>
                <div class="px-3 py-1 bg-blue-100 text-blue-800 rounded-full">3 V√©hicules</div>
                <div class="px-3 py-1 bg-yellow-100 text-yellow-800 rounded-full">10 Cantines</div>
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
            <div class="lg:col-span-3">
                <div id="canvas-container">
                    <canvas id="graphCanvas"></canvas>
                    <div class="help-text">üñ±Ô∏è Molette pour zoomer ‚Ä¢ Clic+Glisser pour d√©placer</div>
                    <div class="controls">
                        <button class="control-btn" onclick="resetView()">Centrer</button>
                        <button class="control-btn" onclick="adjustZoom(1.2)">+</button>
                        <button class="control-btn" onclick="adjustZoom(0.8)">-</button>
                    </div>
                </div>
            </div>

            <div class="bg-white p-6 rounded-lg shadow-sm h-fit">
                <h2 class="font-bold text-gray-800 mb-4">D√©tail des Tourn√©es</h2>
                <div class="space-y-4">
                    <div class="p-3 bg-red-50 border-l-4 border-red-500 rounded">
                        <div class="font-bold text-red-700">V√©hicule 1</div>
                        <div class="text-sm text-red-600 mt-1">D√©p√¥t ‚Üí C5 ‚Üí C9 ‚Üí C8 ‚Üí C2 ‚Üí D√©p√¥t</div>
                    </div>
                    <div class="p-3 bg-blue-50 border-l-4 border-blue-500 rounded">
                        <div class="font-bold text-blue-700">V√©hicule 3</div>
                        <div class="text-sm text-blue-600 mt-1">D√©p√¥t ‚Üí C3 ‚Üí C1 ‚Üí C10 ‚Üí D√©p√¥t</div>
                    </div>
                    <div class="p-3 bg-green-50 border-l-4 border-green-500 rounded">
                        <div class="font-bold text-green-700">V√©hicule 4</div>
                        <div class="text-sm text-green-600 mt-1">D√©p√¥t ‚Üí C6 ‚Üí C4 ‚Üí C7 ‚Üí D√©p√¥t</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Donn√©es
        const nodes = [
            { id: 0, label: "D√©p√¥t", type: "depot", demand: 0 },
            { id: 1, label: "C1", type: "client", demand: 60 },
            { id: 2, label: "C2", type: "client", demand: 18 },
            { id: 3, label: "C3", type: "client", demand: 26 },
            { id: 4, label: "C4", type: "client", demand: 15 },
            { id: 5, label: "C5", type: "client", demand: 44 },
            { id: 6, label: "C6", type: "client", demand: 32 },
            { id: 7, label: "C7", type: "client", demand: 20 },
            { id: 8, label: "C8", type: "client", demand: 10 },
            { id: 9, label: "C9", type: "client", demand: 27 },
            { id: 10, label: "C10", type: "client", demand: 11 }
        ];

        const distanceMatrix = [
            [0, 2.7, 4.6, 2.8, 3, 3.3, 3.1, 2.7, 5.1, 3.9, 4.7],
            [2.7, 0, 3.1, 0.8, 1.8, 2.5, 4.2, 1.4, 3.6, 2.5, 3],
            [4.6, 3.1, 0, 3.3, 4.4, 1.7, 6.8, 4.1, 1.3, 1.7, 1.4],
            [2.8, 0.8, 3.3, 0, 1.9, 2, 4, 1.5, 3.8, 2.8, 3.2],
            [3, 1.8, 4.4, 1.9, 0, 3.4, 2.6, 0.5, 4.7, 4.7, 4.1],
            [3.3, 2.5, 1.7, 2, 3.4, 0, 5.8, 3, 1.8, 0.5, 2.6],
            [3.1, 4.2, 6.8, 4, 2.6, 5.8, 0, 3, 7.4, 6.1, 7.6],
            [2.7, 1.4, 4.1, 1.5, 0.5, 3, 3, 0, 4.6, 3.7, 4.3],
            [5.1, 3.6, 1.3, 3.8, 4.7, 1.8, 7.4, 4.6, 0, 1.4, 2.8],
            [3.9, 2.5, 1.7, 2.8, 4.7, 0.5, 6.1, 3.7, 1.4, 0, 2.8],
            [4.7, 3, 1.4, 3.2, 4.1, 2.6, 7.6, 4.3, 2.8, 2.8, 0]
        ];

        const routes = [
            { id: 1, path: [0, 5, 9, 8, 2, 0], color: "#EF4444" },
            { id: 3, path: [0, 3, 1, 10, 0], color: "#3B82F6" },
            { id: 4, path: [0, 6, 4, 7, 0], color: "#10B981" }
        ];

        // --- Simulation de mise en page (MDS simplifi√©) ---
        const width = 2000; // Grand espace virtuel
        const height = 2000;
        nodes.forEach(n => {
            n.x = Math.random() * width;
            n.y = Math.random() * height;
            n.vx = 0;
            n.vy = 0;
        });

        nodes[0].x = width / 2;
        nodes[0].y = height / 2;
        nodes[0].fixed = true;

        for (let iter = 0; iter < 3000; iter++) {
            nodes.forEach((n, i) => {
                if (n.fixed) return;
                let fx = 0, fy = 0;
                nodes.forEach((m, j) => {
                    if (i === j) return;
                    const dx = n.x - m.x;
                    const dy = n.y - m.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const targetDist = distanceMatrix[i][j] * 180; // Scale factor 180
                    const force = (dist - targetDist) * 0.01;
                    fx -= (dx / dist) * force;
                    fy -= (dy / dist) * force;
                });
                n.vx = (n.vx * 0.9) + fx;
                n.vy = (n.vy * 0.9) + fy;
                n.x += n.vx;
                n.y += n.vy;
            });
        }

        // --- Gestion Canvas / Zoom / Pan ---
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        let viewState = {
            scale: 0.3, // Zoom initial d√©zoom√© pour tout voir
            offsetX: 0,
            offsetY: 0,
            isDragging: false,
            lastX: 0,
            lastY: 0
        };

        function resize() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            draw();
        }
        window.addEventListener('resize', resize);

        // Initial centering
        function resetView() {
            viewState.scale = 0.3;
            viewState.offsetX = canvas.width / 2 - (width / 2) * viewState.scale;
            viewState.offsetY = canvas.height / 2 - (height / 2) * viewState.scale;
            draw();
        }

        function adjustZoom(factor) {
            const newScale = viewState.scale * factor;
            // Zoom vers le centre
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            viewState.offsetX = centerX - (centerX - viewState.offsetX) * (newScale / viewState.scale);
            viewState.offsetY = centerY - (centerY - viewState.offsetY) * (newScale / viewState.scale);
            viewState.scale = newScale;
            draw();
        }

        // Mouse Events
        container.addEventListener('mousedown', e => {
            viewState.isDragging = true;
            viewState.lastX = e.clientX;
            viewState.lastY = e.clientY;
        });

        window.addEventListener('mousemove', e => {
            if (!viewState.isDragging) return;
            const dx = e.clientX - viewState.lastX;
            const dy = e.clientY - viewState.lastY;
            viewState.offsetX += dx;
            viewState.offsetY += dy;
            viewState.lastX = e.clientX;
            viewState.lastY = e.clientY;
            draw();
        });

        window.addEventListener('mouseup', () => viewState.isDragging = false);

        container.addEventListener('wheel', e => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.95 : 1.05;

            // Zoom vers la souris
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const newScale = viewState.scale * factor;
            viewState.offsetX = mouseX - (mouseX - viewState.offsetX) * (newScale / viewState.scale);
            viewState.offsetY = mouseY - (mouseY - viewState.offsetY) * (newScale / viewState.scale);
            viewState.scale = newScale;

            draw();
        });

        function worldToScreen(x, y) {
            return {
                x: x * viewState.scale + viewState.offsetX,
                y: y * viewState.scale + viewState.offsetY
            };
        }

        function drawGrid() {
            const gridSize = 100 * viewState.scale;
            const offsetX = viewState.offsetX % gridSize;
            const offsetY = viewState.offsetY % gridSize;

            ctx.beginPath();
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;

            for (let x = offsetX; x < canvas.width; x += gridSize) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            for (let y = offsetY; y < canvas.height; y += gridSize) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            ctx.stroke();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();

            // Routes
            routes.forEach(route => {
                ctx.beginPath();
                ctx.strokeStyle = route.color;
                ctx.lineWidth = 3; // Fixed line width independent of zoom? Or scaled? Fixed is usually better readable.
                // Scaled line width can be clearer:
                // ctx.lineWidth = 3 * viewState.scale; 
                ctx.lineJoin = 'round';

                route.path.forEach((nodeId, idx) => {
                    const n = nodes[nodeId];
                    const pos = worldToScreen(n.x, n.y);
                    if (idx === 0) ctx.moveTo(pos.x, pos.y);
                    else ctx.lineTo(pos.x, pos.y);
                });
                ctx.stroke();

                // Arrows
                route.path.forEach((nodeId, idx) => {
                    if (idx >= route.path.length - 1) return;
                    const n1 = nodes[nodeId];
                    const n2 = nodes[route.path[idx + 1]];
                    const p1 = worldToScreen(n1.x, n1.y);
                    const p2 = worldToScreen(n2.x, n2.y);

                    const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;

                    const arrowSize = 10; // Fixed size arrows
                    ctx.beginPath();
                    ctx.fillStyle = route.color;
                    ctx.moveTo(midX, midY);
                    ctx.lineTo(midX - arrowSize * Math.cos(angle - Math.PI / 6), midY - arrowSize * Math.sin(angle - Math.PI / 6));
                    ctx.lineTo(midX - arrowSize * Math.cos(angle + Math.PI / 6), midY - arrowSize * Math.sin(angle + Math.PI / 6));
                    ctx.fill();
                });
            });

            // Nodes
            nodes.forEach(n => {
                const pos = worldToScreen(n.x, n.y);

                // Culling simpliste
                if (pos.x < -50 || pos.x > canvas.width + 50 || pos.y < -50 || pos.y > canvas.height + 50) return;

                ctx.beginPath();
                const radius = n.type === 'depot' ? 15 : 10 + n.demand / 10;
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = n.type === 'depot' ? '#1F2937' : '#F59E0B';
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.fill();
                ctx.stroke();

                // Labels need to handle zoom too?
                // Keeping text size somewhat constant or blocking very small scale
                if (viewState.scale > 0.1) {
                    ctx.fillStyle = '#374151';
                    ctx.font = 'bold 12px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText(n.label, pos.x, pos.y - 20);
                    if (n.demand > 0) {
                        ctx.font = '10px Inter';
                        ctx.fillStyle = '#6B7280';
                        ctx.fillText(`(${n.demand})`, pos.x, pos.y - 8);
                    }
                }
            });
        }

        // Initial setup
        resize(); // sets width/height
        resetView(); // sets initial offsets to center
    </script>
</body>

</html>