<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisation Des Tourn√©es - SAE2026</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }

        #canvas-container {
            position: relative;
            width: 100%;
            height: 600px;
            background: #f8fafc;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            cursor: grab;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .control-btn {
            background: white;
            border: 1px solid #e2e8f0;
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            user-select: none;
        }

        .control-btn:hover {
            background: #f1f5f9;
        }

        .help-text {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            color: #64748b;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>

<body class="p-8">
    <div class="max-w-6xl mx-auto">
        <header class="mb-8">
            <h1 class="text-3xl font-bold text-gray-900">Optimisation des Tourn√©es (CVRP)</h1>
            <p class="text-gray-600 mt-2">Visualisation interactive : Zoomez et d√©placez la carte</p>
            <div class="mt-4 flex gap-4 text-sm">
                <div class="px-3 py-1 bg-green-100 text-green-800 rounded-full">Distance Totale: 31.3</div>
                <div class="px-3 py-1 bg-blue-100 text-blue-800 rounded-full">3 V√©hicules</div>
                <div class="px-3 py-1 bg-yellow-100 text-yellow-800 rounded-full">10 Cantines</div>
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
            <div class="lg:col-span-3">
                <div id="canvas-container">
                    <canvas id="graphCanvas"></canvas>
                    <div class="help-text">üñ±Ô∏è Molette pour zoomer ‚Ä¢ Clic+Glisser pour d√©placer</div>
                    <div class="controls">
                        <button class="control-btn" onclick="resetView()">Centrer</button>
                        <button class="control-btn" onclick="adjustZoom(1.2)">+</button>
                        <button class="control-btn" onclick="adjustZoom(0.8)">-</button>
                    </div>
                </div>
            </div>

            <div class="bg-white p-6 rounded-lg shadow-sm h-fit">
                <h2 class="font-bold text-gray-800 mb-4">D√©tail des Tourn√©es</h2>
                <div class="space-y-4">
                    <div class="p-3 bg-red-50 border-l-4 border-red-500 rounded">
                        <div class="font-bold text-red-700">V√©hicule 1</div>
                        <div class="text-sm text-red-600 mt-1">D√©p√¥t ‚Üí C5 ‚Üí C9 ‚Üí C8 ‚Üí C2 ‚Üí D√©p√¥t</div>
                    </div>
                    <div class="p-3 bg-blue-50 border-l-4 border-blue-500 rounded">
                        <div class="font-bold text-blue-700">V√©hicule 3</div>
                        <div class="text-sm text-blue-600 mt-1">D√©p√¥t ‚Üí C3 ‚Üí C1 ‚Üí C10 ‚Üí D√©p√¥t</div>
                    </div>
                    <div class="p-3 bg-green-50 border-l-4 border-green-500 rounded">
                        <div class="font-bold text-green-700">V√©hicule 4</div>
                        <div class="text-sm text-green-600 mt-1">D√©p√¥t ‚Üí C6 ‚Üí C4 ‚Üí C7 ‚Üí D√©p√¥t</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Donn√©es
        const nodes = [
            { id: 0, label: "D√©p√¥t", type: "depot", demand: 0 },
            { id: 1, label: "C1", type: "client", demand: 60 },
            { id: 2, label: "C2", type: "client", demand: 18 },
            { id: 3, label: "C3", type: "client", demand: 26 },
            { id: 4, label: "C4", type: "client", demand: 15 },
            { id: 5, label: "C5", type: "client", demand: 44 },
            { id: 6, label: "C6", type: "client", demand: 32 },
            { id: 7, label: "C7", type: "client", demand: 20 },
            { id: 8, label: "C8", type: "client", demand: 10 },
            { id: 9, label: "C9", type: "client", demand: 27 },
            { id: 10, label: "C10", type: "client", demand: 11 }
        ];

        const distanceMatrix = [
            [0, 2.7, 4.6, 2.8, 3, 3.3, 3.1, 2.7, 5.1, 3.9, 4.7],
            [2.7, 0, 3.1, 0.8, 1.8, 2.5, 4.2, 1.4, 3.6, 2.5, 3],
            [4.6, 3.1, 0, 3.3, 4.4, 1.7, 6.8, 4.1, 1.3, 1.7, 1.4],
            [2.8, 0.8, 3.3, 0, 1.9, 2, 4, 1.5, 3.8, 2.8, 3.2],
            [3, 1.8, 4.4, 1.9, 0, 3.4, 2.6, 0.5, 4.7, 4.7, 4.1],
            [3.3, 2.5, 1.7, 2, 3.4, 0, 5.8, 3, 1.8, 0.5, 2.6],
            [3.1, 4.2, 6.8, 4, 2.6, 5.8, 0, 3, 7.4, 6.1, 7.6],
            [2.7, 1.4, 4.1, 1.5, 0.5, 3, 3, 0, 4.6, 3.7, 4.3],
            [5.1, 3.6, 1.3, 3.8, 4.7, 1.8, 7.4, 4.6, 0, 1.4, 2.8],
            [3.9, 2.5, 1.7, 2.8, 4.7, 0.5, 6.1, 3.7, 1.4, 0, 2.8],
            [4.7, 3, 1.4, 3.2, 4.1, 2.6, 7.6, 4.3, 2.8, 2.8, 0]
        ];

        const routes = [
            { id: 1, path: [0, 5, 9, 8, 2, 0], color: "#EF4444" },
            { id: 3, path: [0, 3, 1, 10, 0], color: "#3B82F6" },
            { id: 4, path: [0, 6, 4, 7, 0], color: "#10B981" }
        ];

        // --- Configuration Physique ---
        const SCALING_FACTOR = 180;
        const width = 2000;
        const height = 2000;

        // Initialisation al√©atoire
        nodes.forEach(n => {
            n.x = Math.random() * width;
            n.y = Math.random() * height;
            n.vx = 0; n.vy = 0;
            n.fixed = false;
        });

        // Setup initial (D√©p√¥t au centre)
        nodes[0].x = width / 2;
        nodes[0].y = height / 2;
        nodes[0].fixed = true; // Fixe sauf si draggu√©

        // --- Moteur Physique Continu ---
        let isPhysicActive = true;

        function updatePhysics() {
            // Param√®tres de simulation
            const friction = 0.2; // Tr√®s fort amortissement (le mouvement s'arr√™te vite)
            const strength = 0.2; // Ressorts rigides
            const maxVel = 50;   // Limite de vitesse pour √©viter les explosions

            let totalEnergy = 0;

            nodes.forEach((n, i) => {
                if (n.fixed && n !== viewState.draggedNode) return;
                if (n === viewState.draggedNode) return;

                let fx = 0, fy = 0;

                nodes.forEach((m, j) => {
                    if (i === j) return;
                    const dx = n.x - m.x;
                    const dy = n.y - m.y;
                    const currentDist = Math.sqrt(dx * dx + dy * dy) || 0.1;
                    const targetDist = distanceMatrix[i][j] * SCALING_FACTOR;

                    const delta = currentDist - targetDist;
                    const force = delta * strength;

                    fx -= (dx / currentDist) * force;
                    fy -= (dy / currentDist) * force;
                });

                n.vx = (n.vx * friction) + fx;
                n.vy = (n.vy * friction) + fy;

                // Limite de vitesse (Capstone)
                const v = Math.sqrt(n.vx * n.vx + n.vy * n.vy);
                if (v > maxVel) {
                    n.vx = (n.vx / v) * maxVel;
                    n.vy = (n.vy / v) * maxVel;
                }

                n.x += n.vx;
                n.y += n.vy;

                totalEnergy += v;
            });

            // Mise en veille si tout est calme
            if (activeInteraction === false && totalEnergy < 0.5) {
                isPhysicActive = false;
            }
        }

        // --- Gestion Canvas / Zoom / Pan ---
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        let viewState = {
            scale: 0.3,
            offsetX: 0,
            offsetY: 0,
            isDraggingMap: false,
            bgDragStartX: 0,
            bgDragStartY: 0,
            draggedNode: null,
            isNodeDragging: false
        };

        function resize() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            isPhysicActive = true; // Force redraw
        }
        window.addEventListener('resize', resize);

        function resetView() {
            viewState.scale = 0.3;
            viewState.offsetX = canvas.width / 2 - (width / 2) * viewState.scale;
            viewState.offsetY = canvas.height / 2 - (height / 2) * viewState.scale;
            isPhysicActive = true; // Force redraw
        }

        function adjustZoom(factor) {
            const newScale = viewState.scale * factor;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            viewState.offsetX = centerX - (centerX - viewState.offsetX) * (newScale / viewState.scale);
            viewState.offsetY = centerY - (centerY - viewState.offsetY) * (newScale / viewState.scale);
            viewState.scale = newScale;
            isPhysicActive = true; // Force redraw
        }

        // --- Syst√®mes de Coordonn√©es ---
        function screenToWorld(sx, sy) {
            return {
                x: (sx - viewState.offsetX) / viewState.scale,
                y: (sy - viewState.offsetY) / viewState.scale
            };
        }

        function worldToScreen(wx, wy) {
            return {
                x: wx * viewState.scale + viewState.offsetX,
                y: wy * viewState.scale + viewState.offsetY
            };
        }

        function getNodeAt(x, y) {
            const mouseWorld = screenToWorld(x, y);
            let found = null;
            // Rayon de s√©lection un peu large pour faciliter le clic
            const hitRadius = 30 / viewState.scale;

            for (let i = nodes.length - 1; i >= 0; i--) {
                const n = nodes[i];
                const dx = n.x - mouseWorld.x;
                const dy = n.y - mouseWorld.y;
                if (Math.sqrt(dx * dx + dy * dy) < hitRadius) {
                    found = n;
                    break;
                }
            }
            return found;
        }

        // --- Interactions Souris ---
        let activeInteraction = false;

        container.addEventListener('mousedown', e => {
            activeInteraction = true;
            isPhysicActive = true; // R√©veil physique
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const node = getNodeAt(mouseX, mouseY);

            if (node) {
                viewState.isNodeDragging = true;
                viewState.draggedNode = node;
                // On "r√©veille" la physique si tout s'√©tait arr√™t√©
                node.vx = 0;
                node.vy = 0;
                container.style.cursor = 'grabbing';
            } else {
                viewState.isDraggingMap = true;
                viewState.bgDragStartX = e.clientX;
                viewState.bgDragStartY = e.clientY;
                container.style.cursor = 'move';
            }
        });

        window.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (viewState.isNodeDragging && viewState.draggedNode) {
                const wPos = screenToWorld(mouseX, mouseY);
                // On met √† jour la position directement (override physics)
                viewState.draggedNode.x = wPos.x;
                viewState.draggedNode.y = wPos.y;
            } else if (viewState.isDraggingMap) {
                const dx = e.clientX - viewState.bgDragStartX;
                const dy = e.clientY - viewState.bgDragStartY;
                viewState.offsetX += dx;
                viewState.offsetY += dy;
                viewState.bgDragStartX = e.clientX;
                viewState.bgDragStartY = e.clientY;
            } else {
                const node = getNodeAt(mouseX, mouseY);
                container.style.cursor = node ? 'grab' : 'default';
            }
        });

        window.addEventListener('mouseup', () => {
            activeInteraction = false;
            if (viewState.draggedNode) {
                // Optionnel: figer le noeud apr√®s d√©placement ? 
                // Pour l'instant on le laisse libre mais avec inertie nulle
                viewState.draggedNode.vx = 0;
                viewState.draggedNode.vy = 0;
            }
            viewState.isNodeDragging = false;
            viewState.draggedNode = null;
            viewState.isDraggingMap = false;
            container.style.cursor = 'default';
        });

        container.addEventListener('wheel', e => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.95 : 1.05;
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const newScale = viewState.scale * factor;
            viewState.offsetX = mouseX - (mouseX - viewState.offsetX) * (newScale / viewState.scale);
            viewState.offsetY = mouseY - (mouseY - viewState.offsetY) * (newScale / viewState.scale);
            viewState.scale = newScale;
            isPhysicActive = true; // Force redraw on zoom
        });

        function drawGrid() {
            const gridSize = 100 * viewState.scale;
            const offsetX = viewState.offsetX % gridSize;
            const offsetY = viewState.offsetY % gridSize;

            ctx.beginPath();
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;

            if (gridSize > 5) { // √âviter de dessiner une grille trop dense
                for (let x = offsetX; x < canvas.width; x += gridSize) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                }
                for (let y = offsetY; y < canvas.height; y += gridSize) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                }
                ctx.stroke();
            }
        }

        // --- Boucle de Rendu (Game Loop) ---
        function loop() {
            if (isPhysicActive || activeInteraction) {
                updatePhysics();
                // Draw only if physics is active or user is interacting
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid();

                // ... (Draw Routes & Nodes - same as before, simplified for diff clarity essentially calling a draw function would be cleaner but keeping inline for stability)
                drawScene();
            }
            requestAnimationFrame(loop);
        }

        function drawScene() {
            // Routes & Labels
            routes.forEach(route => {
                ctx.strokeStyle = route.color;
                ctx.lineWidth = 3;
                ctx.lineJoin = 'round';

                ctx.beginPath();
                route.path.forEach((nodeId, idx) => {
                    const n = nodes[nodeId];
                    const pos = worldToScreen(n.x, n.y);
                    if (idx === 0) ctx.moveTo(pos.x, pos.y);
                    else ctx.lineTo(pos.x, pos.y);
                });
                ctx.stroke();

                route.path.forEach((nodeId, idx) => {
                    if (idx >= route.path.length - 1) return;
                    const nextId = route.path[idx + 1];
                    const n1 = nodes[nodeId];
                    const n2 = nodes[nextId];
                    const p1 = worldToScreen(n1.x, n1.y);
                    const p2 = worldToScreen(n2.x, n2.y);

                    const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;

                    const screenDist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));

                    // On dessine toujours la fl√®che et l'√©tiquette
                    const arrowSize = 10;
                    ctx.beginPath();
                    ctx.fillStyle = route.color;
                    ctx.moveTo(midX, midY);
                    ctx.lineTo(midX - arrowSize * Math.cos(angle - Math.PI / 6), midY - arrowSize * Math.sin(angle - Math.PI / 6));
                    ctx.lineTo(midX - arrowSize * Math.cos(angle + Math.PI / 6), midY - arrowSize * Math.sin(angle + Math.PI / 6));
                    ctx.fill();

                    // Distance Tag
                    const distVal = distanceMatrix[nodeId][nextId];
                    ctx.save();
                    ctx.translate(midX, midY);
                    // Keep text upright
                    if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
                        ctx.rotate(angle + Math.PI);
                    } else {
                        ctx.rotate(angle);
                    }
                    ctx.translate(0, -12); // Move above line

                    // Background for text
                    const text = `${distVal}`;
                    ctx.font = 'bold 11px Inter';
                    const textWidth = ctx.measureText(text).width;

                    ctx.fillStyle = 'white';
                    ctx.roundRect(-textWidth / 2 - 2, -10, textWidth + 4, 14, 2);
                    ctx.fill();
                    ctx.fillStyle = route.color;
                    ctx.textAlign = 'center';
                    ctx.fillText(text, 0, 0);
                    ctx.restore();
                });
            });

            // Nodes
            nodes.forEach(n => {
                const pos = worldToScreen(n.x, n.y);
                if (pos.x < -100 || pos.x > canvas.width + 100 || pos.y < -100 || pos.y > canvas.height + 100) return;

                ctx.beginPath();
                const radius = n.type === 'depot' ? 15 : 10 + n.demand / 10;
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = n.type === 'depot' ? '#1F2937' : '#F59E0B';
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                if (viewState.draggedNode === n) {
                    ctx.strokeStyle = '#3B82F6';
                    ctx.lineWidth = 3;
                }
                ctx.fill();
                ctx.stroke();

                if (viewState.scale > 0.1) {
                    // Label inside the node
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px Inter';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(n.label, pos.x, pos.y);

                    // Reset textBaseline
                    ctx.textBaseline = 'alphabetic';

                    // Demand below the node
                    if (n.demand > 0) {
                        ctx.font = '10px Inter';
                        ctx.fillStyle = '#6B7280';
                        ctx.fillText(`(${n.demand})`, pos.x, pos.y + radius + 12);
                    }
                }
            });
        }

        // Boot
        resize();
        resetView();
        requestAnimationFrame(loop); // Start loop immediately
    </script>
</body>

</html>